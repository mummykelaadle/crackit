import { Julep } from "@julep/sdk";
import dotenv from "dotenv";
import fs from "fs";
import path from "path";
import { Problem, problems } from "../data/problems";

// Initialize Julep client
const client = new Julep({ apiKey: process.env.JULEP_API_KEY });

// Hardcoded Agent and Task IDs - these will be set after running setupInterviewExpAnalyzer.ts
// You should replace these values with the actual IDs generated by the setup script
const ANALYZER_AGENT_ID = "agent_2KgD9lmnY8zRo96VG4CjNF6o";
const ANALYZER_TASK_ID = "task_2d6U1KoQlgMUeAJ9qE7bMpWl";

/**
 * Interface for the interview experience analysis result
 */
export interface InterviewExpAnalysisResult {
  problemId: string;
  problem: Problem;
  behavioralQuestions: string[];
  success: boolean;
  error?: string;
}

/**
 * Reads the agent and task IDs from the configuration file
 * Falls back to hardcoded values if the file doesn't exist
 */
function getAnalyzerIds(): { agentId: string, taskId: string } {
  try {
    const configPath = path.join(__dirname, "../config/interviewAgentInfo.json");
    if (fs.existsSync(configPath)) {
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      return {
        agentId: config.analyzerAgentId || ANALYZER_AGENT_ID,
        taskId: config.analyzerTaskId || ANALYZER_TASK_ID
      };
    }
  } catch (error) {
    console.error("Error reading agent info:", error);
  }
  
  // Fallback to hardcoded values
  return { agentId: ANALYZER_AGENT_ID, taskId: ANALYZER_TASK_ID };
}

/**
 * Analyzes an interview experience article to select a relevant coding problem
 * and extract behavioral questions mentioned in the article.
 * The LLM will select the most appropriate problem based on the article content.
 * 
 * @param interviewExperienceArticle The full text of an interview experience article (e.g. from GeeksForGeeks)
 * @returns Analysis result containing the selected problem and behavioral questions
 */
export async function analyzeInterviewExp(
  interviewExperienceArticle: string
): Promise<InterviewExpAnalysisResult> {
  try {
    // Get the IDs (either from config file or hardcoded)
    const { taskId } = getAnalyzerIds();
    
    // Format the problems for the agent
    const problemsData = problems.map(p => ({
      id: p._id,
      title: p.title,
      difficulty: p.difficulty,
      tags: p.tags,
      description: p.description
    }));
    
    // Provide the problems list without any difficulty filtering
    const problemsInfo = JSON.stringify(problemsData);

    // Create execution with the task
    const execution = await client.executions.create(taskId, {
      input: {
        problems: problemsInfo,
        article: interviewExperienceArticle
      }
    });

    // Wait for the execution to complete
    let result;
    let attempts = 0;
    const maxAttempts = 30; // Maximum 30 seconds wait time
    
    do {
      result = await client.executions.get(execution.id);
      if (result.status === "succeeded") {
        // Parse the results from the execution
        const response = result.output?.response?.trim() || "";
        
        // Extract problem ID from the response
        const problemIdMatch = response.match(/Problem ID: ([a-z0-9]+)/i) || 
                               response.match(/Selected problem: ([a-z0-9]+)/i) ||
                               response.match(/problem_id: "([a-z0-9]+)"/i);
        
        // Extract behavioral questions from the response
        const behavioralQuestionsMatch = response.match(/Behavioral Questions:([\s\S]*?)(?=Problem|$)/i) ||
                                         response.match(/Behavioral Questions:([\s\S]*)/i);
        
        let problemId = problemIdMatch ? problemIdMatch[1] : "6802cff382aab64098bd479c"; // Default to Two Sum
        let behavioralQuestions: string[] = [];
        
        if (behavioralQuestionsMatch) {
          behavioralQuestions = behavioralQuestionsMatch[1]
            .split(/\n\s*\d+\.\s*|\n\s*-\s*/)
            .map(q => q.trim())
            .filter(q => q.length > 0 && q.endsWith('?'));
        }
        
        // If no behavioral questions were extracted, provide default ones
        if (behavioralQuestions.length === 0) {
          behavioralQuestions = [
            "Tell me about yourself?",
            "Why do you want to work at our company?",
            "Describe a challenging situation you faced and how you handled it?"
          ];
        }
        
        // Find the problem by ID
        const problem = problems.find(p => p._id === problemId);
        
        if (!problem) {
          // If problem not found, default to Two Sum
          problemId = "6802cff382aab64098bd479c"; 
          return {
            problemId,
            problem: problems.find(p => p._id === problemId)!,
            behavioralQuestions,
            success: true
          };
        }
        
        return {
          problemId,
          problem,
          behavioralQuestions,
          success: true
        };
      } else if (result.status === "failed") {
        throw new Error(`Execution failed: ${result.error || "Unknown error"}`);
      }
      
      await new Promise((res) => setTimeout(res, 1000));
      attempts++;
    } while (!["succeeded", "failed"].includes(result.status) && attempts < maxAttempts);

    if (attempts >= maxAttempts) {
      throw new Error("Execution timed out");
    }

    throw new Error("Execution failed with unknown error");
  } catch (error) {
    console.error("Error in interview experience analysis:", error);
    
    // Fallback to default selection in case of any error
    return {
      problemId: "6802cff382aab64098bd479c", // Two Sum problem
      problem: problems.find(p => p._id === "6802cff382aab64098bd479c")!,
      behavioralQuestions: [
        "Tell me about yourself?",
        "Why do you want to work at our company?",
        "Describe a challenging situation you faced and how you handled it?"
      ],
      success: false,
      error: error instanceof Error ? error.message : "Unknown error"
    };
  }
}